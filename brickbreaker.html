<!DOCTYPE html>
<html lang="en">
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
        <meta content="utf-8" http-equiv="encoding">
    </head>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        var canvas;
        var canvasContext;

        var ballX = 75;
        var ballY = 75;
        var ballSpeedX = 6; 
        var ballSpeedY = 6;

        var paddleX = 0;

        var brickCounter = 0; // To keep track of bricks.

        const PADDLE_WIDTH = 100;
        const PADDLE_THICKNESS = 10;
        const PADDLE_Y = 540;

        const BRICK_W = 80; // Brick collision width.
        const BRICK_H = 20; // Brick collision height.
        const BRICK_GAP = 2; // Visual gap between bricks.
        const BRICK_COLS = 10; // Number of brick columns.
        const BRICK_ROWS = 14; 

        var brickGrid = new Array(BRICK_COLS * BRICK_ROWS);

        function resetBricks() {
            brickCounter = 0;

            for (var i=0; i < BRICK_COLS * BRICK_ROWS; i++) {
                if (i >= 30)
                {
                    brickGrid[i] = 1;
                    brickCounter ++; // Add a brick to the counter for each brick in grid.
                }
                else
                {
                    brickGrid[i] = 0;
                }
            }
        }

        function brickTileToIndex(tileCol, tileRow) {
            return (tileCol + BRICK_COLS * tileRow);
        }

        function isBrickAtTileCoord(brickTileCol, brickTileRow) {
            var brickIndex = brickTileToIndex(brickTileCol, brickTileRow);
            return (brickGrid[brickIndex] == 1);
        }

        function breakAndBounceOffBrickAtPixelCoord(pixelX, pixelY) {
            var tileCol = pixelX / BRICK_W;
            var tileRow = pixelY / BRICK_H;

            tileCol = Math.floor(tileCol);
            tileRow = Math.floor(tileRow);

            // To aoid index out of bounds make sure it's within the brick wall.
            if (tileCol < 0 || tileCol >= BRICK_COLS ||
                tileRow < 0 || tileRow >= BRICK_ROWS) {
                return;
            }

            var brickIndex = brickTileToIndex(tileCol, tileRow);

            // Check if it's overlapping a visible brick.
            if (brickGrid[brickIndex] == 1) {
                // We need to compare to where the ball was the previous frame.
                var prevBallX = ballX - ballSpeedX;
                var prevBallY = ballY - ballSpeedY;
                var prevTileCol = Math.floor(prevBallX / BRICK_W);
                var prevTileRow = Math.floor(prevBallY / BRICK_H);

                var bothTestsFailed = true;

                // Came in horizontally.
                if (prevTileCol != tileCol) {
                    var adjacentBrickIndex = brickTileToIndex(prevTileCol, tileRow);

                    // Make sure the side of brick hit isn't blocked by adjacent brick
                    // before flipping it's horizontal motion.
                    if (brickGrid[adjacentBrickIndex] != 1) {
                        ballSpeedX *= -1;
                        bothTestsFailed = false;
                    }
                }

                // Came in vertically.
                if (prevTileRow != tileRow) {
                    var adjacentBrickIndex = brickTileToIndex(tileCol, prevTileRow);

                    // Make sure the brick side isn't blocked by adjacent brick
                    // before flipping it's vertical motion.
                    if (brickGrid[adjacentBrickIndex] != 1) {
                        ballSpeedY *= -1;
                        bothTestsFailed = false;
                    }
                }

                if (bothTestsFailed) {
                    ballSpeedX *= -1;
                    ballSpeedY *= -1;
                }

                brickGrid[brickIndex] = 0;
                brickCounter --;
            }
        }

        window.onload = function() {            
            // Save the canvas for dimensions and its 2d context for drawing to it.
            canvas = document.getElementById('gameCanvas');
            canvasContext = canvas.getContext('2d');
            paddleX = (canvas.width / 2) - (PADDLE_WIDTH/2);

            ballReset();
            resetBricks();

            var framesPerSecond = 30;

            // Calls function every N number of milliseconds.
            setInterval(function() // Anonymous function for calling multiple functions for each interval.
                {
                    moveEverything();
                    drawEverything();
                }, 1000/framesPerSecond); // 1000 equals one sec. Divide by frames to get fps.

            // Each time the mouse is moved the coordinates are calculated and the paddle is moved from center
            // where the mouse is at horizontally.
            canvas.addEventListener('mousemove', 
                function(evt)
                {
                    var mousePos = calculateMousePos(evt);
                    paddleX = mousePos.x - (PADDLE_WIDTH/2);

                    //ballX = mousePos.x;
                    //ballY = mousePos.y;
                });
        }

        function drawEverything() {
            // Black out the screen before drawing everything.
            colorRect(0, 0, canvas.width, canvas.height, 'black');

            drawBricks();

            // Draw the ball.
            colorCircle(ballX, ballY, 6, 'white');

            // Draw the paddle.
            colorRect(paddleX, PADDLE_Y, PADDLE_WIDTH, PADDLE_THICKNESS, 'white');
        }

        function drawBricks() {
            for (var row = 0; row < BRICK_ROWS; row++) {
                for (var column = 0; column < BRICK_COLS; column ++) {

                    if (isBrickAtTileCoord(column, row)) {
                        var brickTopLeftX = column * BRICK_W;
                        var brickTopLeftY = row * BRICK_H;
                    
                        colorRect(brickTopLeftX, brickTopLeftY, BRICK_W - BRICK_GAP, BRICK_H - BRICK_GAP, 'blue');
                    }
                }
            }

        }

        function colorRect(topLeftX, topLeftY, boxWidth, boxHeight, fillColor) {
            canvasContext.fillStyle = fillColor;
            canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
        }

        function colorCircle(centerX, centerY, radius, fillColor) {
            canvasContext.fillStyle = fillColor;
            canvasContext.beginPath(); // Tells browser that this is a new, separate shape.
            // x, y (from center), radius, start, and end angles. True means draw counterclockwise.
            canvasContext.arc(centerX, centerY, radius, 0, Math.PI*2, true); 
            canvasContext.fill(); // color in shape formed since beginPath().
        }

        function moveEverything() {
            // Ball collidges with left edge, reverse ball.
            if (ballX < 0) {
                ballSpeedX *= -1;
            }

            // Ball collides with right edge, reverse ball.
            if (ballX > canvas.width) {
                ballSpeedX *= -1;
            }

            // Ball collides with top edge, reverse ball.
            if (ballY < 0) {
                ballSpeedY *= -1;
            }

            // Ball collides with bottom edge, reset ball.
            if (ballY > canvas.height) {
                ballReset();
            }

            // Ball collides with paddle.
            if (ballSpeedY > 0) { // Ball should be moving down before any paddle collision happens.
                if (ballY >= PADDLE_Y &&  // Top of paddle.
                    ballY <= PADDLE_Y + PADDLE_THICKNESS) { // Bottom of paddle.

                    if (brickCounter <= 0) {
                        resetBricks();
                    }
                    if (ballX > paddleX && // To the right of left side of paddle.
                        ballX < paddleX + PADDLE_WIDTH) { // To the left of right side of paddle.
                        var paddleCenter = paddleX + (PADDLE_WIDTH / 2);
                        var delta = ballX - paddleCenter;
                        ballSpeedX = delta * 0.25;
                        ballSpeedY *= -1;
                    }
                }
            }

            breakAndBounceOffBrickAtPixelCoord(ballX, ballY);

            // Ball constant movement by speed.
            ballX += ballSpeedX;
            ballY += ballSpeedY;
        }

        function ballReset() {
            ballX = canvas.width / 2;
            ballY = canvas.height / 2;
        }

        function calculateMousePos(evt) {
            var rect = canvas.getBoundingClientRect(), root = document.documentElement;

            // Account for the margins, canvas position on page, scroll amount, etc...
            var mouseX = evt.clientX - rect.left - root.scrollLeft;
            var mouseY = evt.clientY - rect.top - root.scrollTop;

            return {
                x: mouseX,
                y: mouseY
            };
        }
    </script>
</html>